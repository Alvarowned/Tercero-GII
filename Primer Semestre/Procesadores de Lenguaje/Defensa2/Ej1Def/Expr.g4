grammar Expr;		
prog: include* function*;
comentario: (COMENTARIO_BLOQUE | COMENTARIO_LINEA);
punto_coma: PUNTO_COMA;
palabra_reservada_include: INCLUDE;
nombre_variable: PALABRA;
variable_numerica: NUMERO;
cadena_de_texto: STRING;
tipo_de_dato: variable_numerica | cadena_de_texto | nombre_variable;
palabra_reservada_and: AND;
palabra_reservada_or: OR;
palabra_reservada_begin: BEGIN;
palabra_reservada_end: END;
palabra_reservada_function: FUNCTION;
palabra_reservada_main: MAIN;
palabra_reservada_while: WHILE;
palabra_reservada_if: IF;
palabra_reservada_for: FOR;
include: palabra_reservada_include nombre_variable punto_coma;
operador_logico: palabra_reservada_and | palabra_reservada_or;
op_suma: SUMA;
op_resta: RESTA;
op_multiplicacion: MULTIPLICACION;
op_division: DIVISION;
operador_aritmetico: op_suma | op_resta | op_multiplicacion | op_division;
operacion: ((tipo_de_dato | llamada) operador_aritmetico)+ (tipo_de_dato | llamada);
nombre_funcion: PALABRA;
llamada: nombre_funcion PI ((tipo_de_dato | llamada | operacion) COMA)* (tipo_de_dato | llamada | operacion)? PD;
palabra_reservada_asignar: ASIGNAR;
palabra_reservada_void: VOID;
asignacion: nombre_variable palabra_reservada_asignar (tipo_de_dato | llamada | operacion | palabra_reservada_void);
palabra_reservada_cadena: PR_CADENA;
palabra_reservada_numero: PR_NUMERO;
tipo_de_variable: palabra_reservada_cadena | palabra_reservada_numero;
declaracion: tipo_de_variable nombre_variable palabra_reservada_asignar (tipo_de_dato | llamada | operacion | palabra_reservada_void);
expr_comparacion: tipo_de_dato ((MAYOR_QUE | MENOR_QUE) IGUAL?) tipo_de_dato;
expr_condicional: (expr_comparacion (operador_logico))* expr_comparacion;
while_cab: palabra_reservada_while PI expr_condicional PD;
while_cuerpo: palabra_reservada_begin (if_funct | for_loop | while_loop | ((asignacion | declaracion | llamada) punto_coma))* palabra_reservada_end;
while_loop: while_cab while_cuerpo;
for_loop: for_cab for_cuerpo;
for_cab: palabra_reservada_for PI (declaracion | asignacion) PUNTO_COMA expr_comparacion PUNTO_COMA tipo_de_dato (INCREMENTO | DECREMENTO) PD;
for_cuerpo: palabra_reservada_begin (if_funct | for_loop | while_loop | ((asignacion | declaracion | llamada) punto_coma))* palabra_reservada_end;
if_funct: if_cab if_cuerpo;
if_cab: palabra_reservada_if PI expr_condicional PD;
if_cuerpo: palabra_reservada_begin (if_funct | for_loop | while_loop | ((asignacion | declaracion | llamada) punto_coma))* palabra_reservada_end;
function_cab: palabra_reservada_function (palabra_reservada_main | nombre_funcion) PI ((tipo_de_variable nombre_variable COMA)* (tipo_de_variable nombre_variable))? PD DOS_PUNTOS (palabra_reservada_void | tipo_de_variable);
function_cuerpo: palabra_reservada_begin (while_loop | ((asignacion | declaracion | llamada) punto_coma))* palabra_reservada_end;
function: function_cab function_cuerpo;



COMENTARIO_LINEA: '//' .*? '\n' -> skip;
COMENTARIO_BLOQUE: (('/*' .*? '*/') | ('/**' .*? '**/') | ('/***' .*? '***/')) -> skip;
PUNTO_COMA: ';';
DOS_PUNTOS: ':';
COMA: ',';
ASIGNAR: ':=';
FUNCTION: 'function';
MAIN: 'main';
WHILE: 'while';
IF: 'if';
FOR: 'for';
PI: '(';
PD: ')';
SUMA: '+';
RESTA: '-';
INCREMENTO: '++';
DECREMENTO: '--';
MULTIPLICACION: '*';
DIVISION: '/';
MAYOR_QUE: '>';
MENOR_QUE: '<';
IGUAL: '=';
AND: '&&';
OR: '||';
BEGIN: 'begin';
END: 'end';
INCLUDE: 'include'; 
VOID: 'void';          // VOID POR SEPARADO PORQUE NO ACTUA SIEMPRE IGUAL QUE UN TIPO DE VARIABLE
PR_CADENA: 'cadena';
PR_NUMERO:'numero';
fragment INT: [0-9];
PUNTO: '.';
NUMERO: INT+ PUNTO? INT*;
COMILLAS: '"';
STRING: COMILLAS .*? COMILLAS;
fragment LETRA: [a-zA-Z];
PALABRA: LETRA (LETRA | INT | '_')*;    // COMPROBAR VALIDEZ DE '_'
SOBRAS: [ \n\t\r]+ -> skip; 