parser grammar AParser;
options {
    tokenVocab = ALexer;
    language = Java;
}

prog: include* function*;
comentario: (COMENTARIO_BLOQUE | COMENTARIO_LINEA);
punto_coma: PUNTO_COMA;
palabra_reservada_include: INCLUDE;
nombre_variable: PALABRA;
variable_numerica: NUMERO;
cadena_de_texto: STRING;
tipo_de_dato: variable_numerica | cadena_de_texto | nombre_variable;
palabra_reservada_and: AND;
palabra_reservada_or: OR;
palabra_reservada_begin: BEGIN;
palabra_reservada_end: END;
palabra_reservada_function: FUNCTION;
palabra_reservada_main: MAIN;
palabra_reservada_while: WHILE;
palabra_reservada_if: IF;
palabra_reservada_for: FOR;
include: palabra_reservada_include nombre_variable punto_coma;
operador_logico: palabra_reservada_and | palabra_reservada_or;
op_suma: SUMA;
op_resta: RESTA;
op_multiplicacion: MULTIPLICACION;
op_division: DIVISION;
operador_aritmetico: op_suma | op_resta | op_multiplicacion | op_division;
operacion: ((tipo_de_dato | llamada) operador_aritmetico)+ (tipo_de_dato | llamada);
nombre_funcion: PALABRA;
llamada: nombre_funcion PI ((tipo_de_dato | llamada | operacion) COMA)* (tipo_de_dato | llamada | operacion)? PD;
palabra_reservada_asignar: ASIGNAR;
palabra_reservada_void: VOID;
asignacion: nombre_variable palabra_reservada_asignar (tipo_de_dato | llamada | operacion | palabra_reservada_void);
palabra_reservada_cadena: PR_CADENA;
palabra_reservada_numero: PR_NUMERO;
tipo_de_variable: palabra_reservada_cadena | palabra_reservada_numero;
declaracion: tipo_de_variable nombre_variable palabra_reservada_asignar (tipo_de_dato | llamada | operacion | palabra_reservada_void);
expr_comparacion: tipo_de_dato ((MAYOR_QUE | MENOR_QUE) IGUAL?) tipo_de_dato;
expr_condicional: (expr_comparacion (operador_logico))* expr_comparacion;
while_cab: palabra_reservada_while PI expr_condicional PD;
while_cuerpo: palabra_reservada_begin (if_funct | for_loop | while_loop | ((asignacion | declaracion | llamada) punto_coma))* palabra_reservada_end;
while_loop: while_cab while_cuerpo;
for_loop: for_cab for_cuerpo;
for_cab: palabra_reservada_for PI (declaracion | asignacion) PUNTO_COMA expr_comparacion PUNTO_COMA tipo_de_dato (INCREMENTO | DECREMENTO) PD;
for_cuerpo: palabra_reservada_begin (if_funct | for_loop | while_loop | ((asignacion | declaracion | llamada) punto_coma))* palabra_reservada_end;
if_funct: if_cab if_cuerpo;
if_cab: palabra_reservada_if PI expr_condicional PD;
if_cuerpo: palabra_reservada_begin (if_funct | for_loop | while_loop | ((asignacion | declaracion | llamada) punto_coma))* palabra_reservada_end;
function_cab: palabra_reservada_function (palabra_reservada_main | nombre_funcion) PI ((tipo_de_variable nombre_variable COMA)* (tipo_de_variable nombre_variable))? PD DOS_PUNTOS (palabra_reservada_void | tipo_de_variable);
function_cuerpo: palabra_reservada_begin (while_loop | ((asignacion | declaracion | llamada) punto_coma))* palabra_reservada_end;
function: function_cab function_cuerpo;